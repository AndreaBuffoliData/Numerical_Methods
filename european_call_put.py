# -*- coding: utf-8 -*-
"""European_Call.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xiCenAN65Af_eUK5hdN0_rtkn1lnzInH
"""

import numpy as np
import plotly.graph_objects as go

def finite_difference(S, K, T, sigma, r, q, N, Nj, CallPut):
    """
    Pricing method for European options using the Crank-Nicolson method.

    Variables:
    - S: Initial underlying asset price
    - K: Strike price
    - T: Time to maturity in years
    - sigma: Volatility of the underlying asset
    - r: Risk-free interest rate
    - q: Dividend yield
    - N: Number of time intervals
    - Nj: Number of partitions in the price space
    - CallPut: Type of option ('Call' or 'Put')

    This function returns the estimated option value using the Crank-Nicolson method.
    """

    dt = T / N
    dx = sigma * np.sqrt(3 * dt)
    nu = r - q - 0.5 * sigma ** 2

    pu = -0.25 * dt * ((sigma / dx) ** 2 + nu / dx)
    pm = 1.0 + 0.5 * dt * ((sigma / dx) ** 2) + 0.5 * r * dt
    pd = -0.25 * dt * ((sigma / dx) ** 2 - nu / dx)

    grid = np.zeros((N+1, 2*Nj+1))

    St = np.linspace(0, 2*K, 2*Nj+1)
    grid[-1, :] = np.maximum(St - K, 0) if CallPut == 'Call' else np.maximum(K - St, 0)

    lambdaU = St[-1] - St[-2] if CallPut == 'Call' else 0.0
    lambdaL = 0.0 if CallPut == 'Call' else -(St[1] - St[0])

    def solve_tridiagonal(C, pu, pm, pd, lambdaL, lambdaU, Nj):
        C1 = np.zeros_like(C)
        pmp = np.zeros(2*Nj+1)
        pp = np.zeros(2*Nj+1)

        pmp[1] = pm + pd
        pp[1] = C[1] + pd * lambdaL

        for j in range(2, 2*Nj):
            pmp[j] = pm - (pu * pd) / pmp[j-1]
            pp[j] = C[j] - (pp[j-1] * pd) / pmp[j-1]

        C1[2*Nj] = (pp[2*Nj-1] + lambdaU) / (pu + pmp[2*Nj-1])
        for j in range(2*Nj-1, 0, -1):
            C1[j] = (pp[j] - pu * C1[j+1]) / pmp[j]
        C1[0] = lambdaL + C1[1]

        return C1

    for i in range(N-1, -1, -1):
        grid[i, :] = solve_tridiagonal(grid[i+1, :], pu, pm, pd, lambdaL, lambdaU, Nj)

    return grid

# Example of a 3D plot for Crank-Nicolson
S, K, T, sigma, r, q, N, Nj = 100, 100, 1, 0.2, 0.05, 0.0, 100, 100
grid = finite_difference(S, K, T, sigma, r, q, N, Nj, 'Call')
X, Y = np.meshgrid(np.linspace(0, T, N+1), np.linspace(0, 2*K, 2*Nj+1))
Z = grid.T

fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y)])
fig.update_layout(title='Option Price Evolution - Crank-Nicolson', scene=dict(xaxis_title='Time', yaxis_title='Underlying Price', zaxis_title='Option Value'))
fig.show()